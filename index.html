<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>سبورة الرياضيات التفاعلية</title>
    <style>
        body {
            margin: 0;
            font-family: 'Cairo', sans-serif;
            background: linear-gradient(120deg, #3498db, #8e44ad);
            color: #fff;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
        }
        header {
            background: #2c3e50;
            padding: 15px;
            text-align: center;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            border-bottom: 3px solid #3498db;
        }
        header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            color: #ecf0f1;
        }
        header p {
            margin: 5px 0;
            font-size: 16px;
            color: #bdc3c7;
        }
        header p.credit {
            font-size: 12px;
            color: #3498db;
        }
        #mainContainer {
            display: flex;
            flex-grow: 1;
            padding: 10px;
            width: 100%;
        }
        #leftToolbar, #rightToolbar {
            width: 15%;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            height: calc(100vh - 120px);
            overflow-y: auto;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            margin: 0 5px;
            transition: transform 0.3s ease;
        }
        #leftToolbar:hover, #rightToolbar:hover {
            transform: scale(1.02);
        }
        #canvasContainer {
            flex-grow: 1;
            text-align: center;
            position: relative;
            padding: 10px;
            width: 70%;
        }
        #canvas {
            border: 4px solid #2c3e50;
            width: 100%;
            height: auto;
            max-width: 1000px;
            aspect-ratio: 10 / 7;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            touch-action: none;
            transition: border-color 0.3s ease;
        }
        #canvas:hover {
            border-color: #3498db;
        }
        .tool-btn {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            cursor: pointer;
            border: none;
            background: #ecf0f1;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .tool-btn:hover {
            background: #3498db;
            color: #fff;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        .tool-btn.active {
            background: #e74c3c;
            color: #fff;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        .panel {
            position: absolute;
            top: 10%;
            right: 20%;
            padding: 15px;
            border: 2px solid #3498db;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            display: none;
            color: #2c3e50;
            z-index: 10;
            max-width: 300px;
            width: 30%;
            cursor: move;
        }
        .panel.dragging {
            opacity: 0.8;
        }
        #timer {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 22px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 25px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            color: #2c3e50;
        }
        #timer.warning {
            color: #e74c3c;
            animation: blink 0.5s infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        select, input[type="text"], textarea {
            width: 100%;
            padding: 8px;
            margin: 6px 0;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            font-family: 'Cairo', sans-serif;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        select:focus, input:focus, textarea:focus {
            border-color: #3498db;
            outline: none;
        }
        button {
            background: #3498db;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease, transform 0.2s ease;
        }
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .input-group button {
            padding: 5px 10px;
            font-size: 12px;
            background: #3498db;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .input-group button:hover {
            background: #2980b9;
        }
        @media (max-width: 768px) {
            #mainContainer {
                flex-direction: column;
                padding: 5px;
            }
            #leftToolbar, #rightToolbar {
                width: 100%;
                height: auto;
                margin: 5px 0;
            }
            #canvasContainer {
                width: 100%;
                padding: 5px;
            }
            #canvas {
                max-width: 100%;
                height: auto;
                aspect-ratio: 10 / 7;
            }
            .panel {
                position: fixed;
                top: 10%;
                right: 5%;
                width: 80%;
                max-width: 90%;
            }
            .tool-btn {
                font-size: 12px;
            }
            header h1 {
                font-size: 24px;
            }
            header p {
                font-size: 14px;
            }
            #timer {
                font-size: 18px;
                padding: 6px 12px;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>سبورة الرياضيات التفاعلية</h1>
        <p>لمدرسة خالد بن أحمد الإعدادية للبنين</p>
        <p class="credit">إنتاج: عبدالله السالم</p>
    </header>
    <div id="mainContainer">
        <div id="leftToolbar">
            <button class="tool-btn" id="penBtn">قلم</button>
            <button class="tool-btn" id="eraserBtn">ممحاة</button>
            <button class="tool-btn" id="compassBtn">فرجار</button>
            <button class="tool-btn" id="polygonBtn">مضلع</button>
            <button class="tool-btn" id="pointBtn">نقطة</button>
        </div>
        <div id="canvasContainer">
            <span id="timer">00:00</span>
            <canvas id="canvas"></canvas>
        </div>
        <div id="rightToolbar">
            <button class="tool-btn" id="gridBtn">شبكة</button>
            <button class="tool-btn" id="numberLineBtn">خط أعداد</button>
            <button class="tool-btn" id="functionBtn">محلل الدوال</button>
            <button class="tool-btn" id="transformBtn">تحويل</button>
            <button class="tool-btn" id="multiplicationBtn">جدول الضرب</button>
            <button class="tool-btn" id="rulerBtn">مسطرة</button>
            <button class="tool-btn" id="timerBtn">مؤقت</button>
            <button class="tool-btn" id="screenshotBtn">تصوير الشاشة</button>
            <button class="tool-btn" id="spinnerBtn">دوارة الطلاب</button>
            <button class="tool-btn" id="undoBtn">تراجع</button>
            <button class="tool-btn" id="redoBtn">عودة</button>
            <button class="tool-btn" id="clearBtn">مسح الكل</button>
            <select id="colorPicker">
                <option value="black">أسود</option>
                <option value="red">أحمر</option>
                <option value="blue">أزرق</option>
                <option value="green">أخضر</option>
            </select>
            <input type="number" id="lineWidth" min="1" max="10" value="2">
            <label>سمك الخط</label>
            <input type="number" id="eraserSize" min="1" max="20" value="5">
            <label>حجم الممحاة</label>
        </div>
        <div id="gridInput" class="panel">
            <label>القفزة (بالوحدات):</label>
            <div class="input-group">
                <input type="number" id="step" min="1" step="1" value="1">
                <button onclick="increment('step', 1)">+</button>
                <button onclick="increment('step', -1)">-</button>
            </div><br>
            <button onclick="drawGrid()">ارسم الشبكة</button>
        </div>
        <div id="numberLineInput" class="panel">
            <label>القفزة:</label>
            <div class="input-group">
                <input type="number" id="nlStep" min="1" step="1" value="1">
                <button onclick="increment('nlStep', 1)">+</button>
                <button onclick="increment('nlStep', -1)">-</button>
            </div><br>
            <button onclick="drawNumberLine()">ارسم خط الأعداد</button>
        </div>
        <div id="functionInput" class="panel">
            <label>الدالة:</label><input type="text" id="funcInput"><br>
            <select id="funcPresets" onchange="document.getElementById('funcInput').value = this.value;">
                <option value="">اختر دالة</option>
                <option value="x^2">x²</option>
                <option value="sin(x)">sin(x)</option>
                <option value="cos(x)">cos(x)</option>
                <option value="tan(x)">tan(x)</option>
                <option value="sqrt(x)">√x</option>
                <option value="log(x)">log(x)</option>
            </select><br>
            <label>تعليق:</label><input type="text" id="funcLabel"><br>
            <button onclick="drawFunction()">ارسم الدالة</button>
        </div>
        <div id="transformMenu" class="panel">
            <label>إزاحة X (مربعات):</label><div class="input-group"><input type="text" id="shiftX" pattern="[+-]?\d*\.?\d+" step="0.1"><button onclick="increment('shiftX', 0.1)">+</button><button onclick="increment('shiftX', -0.1)">-</button></div><br>
            <label>إزاحة Y (مربعات):</label><div class="input-group"><input type="text" id="shiftY" pattern="[+-]?\d*\.?\d+" step="0.1"><button onclick="increment('shiftY', 0.1)">+</button><button onclick="increment('shiftY', -0.1)">-</button></div><br>
            <label>التكبير:</label><div class="input-group"><input type="text" id="scale" pattern="[+-]?\d*\.?\d+" step="0.1" min="0.1" value="1"><button onclick="increment('scale', 0.1)">+</button><button onclick="increment('scale', -0.1)">-</button></div><br>
            <label>الدوران (درجة):</label><div class="input-group"><input type="text" id="rotate" pattern="[+-]?\d*"><button onclick="increment('rotate', 1)">+</button><button onclick="increment('rotate', -1)">-</button></div><br>
            <button onclick="applyTransform()">تطبيق</button>
            <button onclick="closeTransformMenu()" style="background: #e74c3c; margin-top: 10px;">إغلاق</button>
        </div>
        <div id="multiplicationTable" class="panel" style="width: 300px;">
            <h3>جدول الضرب العشوائي</h3>
            <div id="tableContent"></div>
        </div>
        <div id="spinnerInput" class="panel">
            <label>أدخل الأسماء (كل اسم في سطر):</label><br>
            <textarea id="studentNames" rows="5" cols="30"></textarea><br>
            <button onclick="spinWheel()">ابدأ الدوران</button>
            <canvas id="spinnerCanvas" width="400" height="400"></canvas>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // إنشاء صوت افتراضي باستخدام AudioContext
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let isWhistlePlaying = false;

        function playBeep(duration = 200, frequency = 440) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function playLongBeep(duration = 1000) {
            playBeep(duration, 880);
        }

        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = containerWidth > 1000 ? 1000 : containerWidth;
            canvas.height = canvas.width * 0.7;
            ctx.lineCap = 'round';
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
            ctx.lineWidth = 2;
            redrawAll();
        }

        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        const state = {
            tool: null,
            drawing: false,
            startX: 0,
            startY: 0,
            polygons: [],
            circles: [],
            points: [],
            currentPolygon: [],
            history: [],
            redoHistory: [],
            grid: null,
            numberLine: null,
            functions: [],
            ruler: null,
            polygonHistory: [],
            redoPolygonHistory: [],
            remainingNames: [],
            lastSelectedName: null
        };

        const buttons = document.querySelectorAll('.tool-btn');
        buttons.forEach(btn => btn.addEventListener('click', () => activateTool(btn.id)));

        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX || e.touches?.[0]?.clientX || e.pageX) - rect.left,
                y: (e.clientY || e.touches?.[0]?.clientY || e.pageY) - rect.top
            };
        }

        function activateTool(toolId) {
            stopAllTools();
            buttons.forEach(btn => btn.classList.remove('active'));
            const btn = document.getElementById(toolId);
            btn.classList.add('active');
            state.tool = toolId;

            if (toolId === 'penBtn') startPen();
            else if (toolId === 'eraserBtn') startEraser();
            else if (toolId === 'compassBtn') startCompass();
            else if (toolId === 'polygonBtn') startPolygon();
            else if (toolId === 'pointBtn') startPoint();
            else if (toolId === 'gridBtn') document.getElementById('gridInput').style.display = 'block';
            else if (toolId === 'numberLineBtn') document.getElementById('numberLineInput').style.display = 'block';
            else if (toolId === 'functionBtn') document.getElementById('functionInput').style.display = 'block';
            else if (toolId === 'transformBtn') showTransformMenu();
            else if (toolId === 'multiplicationBtn') showMultiplicationTable();
            else if (toolId === 'rulerBtn') startRuler();
            else if (toolId === 'timerBtn') startTimer();
            else if (toolId === 'screenshotBtn') takeScreenshot();
            else if (toolId === 'spinnerBtn') document.getElementById('spinnerInput').style.display = 'block';
            else if (toolId === 'undoBtn') undo();
            else if (toolId === 'redoBtn') redo();
            else if (toolId === 'clearBtn') clearAll();
        }

        function stopAllTools() {
            state.tool = null;
            state.drawing = false;
            canvas.removeEventListener('mousedown', penStart);
            canvas.removeEventListener('mousemove', penDraw);
            canvas.removeEventListener('mouseup', endPosition);
            canvas.removeEventListener('touchstart', penStart);
            canvas.removeEventListener('touchmove', penDraw);
            canvas.removeEventListener('touchend', endPosition);
            canvas.removeEventListener('pointerdown', penStart);
            canvas.removeEventListener('pointermove', penDraw);
            canvas.removeEventListener('pointerup', endPosition);
            canvas.removeEventListener('mousedown', eraserStart);
            canvas.removeEventListener('mousemove', erase);
            canvas.removeEventListener('mouseup', endPosition);
            canvas.removeEventListener('touchstart', eraserStart);
            canvas.removeEventListener('touchmove', erase);
            canvas.removeEventListener('touchend', endPosition);
            canvas.removeEventListener('pointerdown', eraserStart);
            canvas.removeEventListener('pointermove', erase);
            canvas.removeEventListener('pointerup', endPosition);
            canvas.removeEventListener('mousedown', compassStart);
            canvas.removeEventListener('mousemove', previewRadius);
            canvas.removeEventListener('mouseup', finishCircle);
            canvas.removeEventListener('touchstart', compassStart);
            canvas.removeEventListener('touchmove', previewRadius);
            canvas.removeEventListener('touchend', finishCircle);
            canvas.removeEventListener('pointerdown', compassStart);
            canvas.removeEventListener('pointermove', previewRadius);
            canvas.removeEventListener('pointerup', finishCircle);
            canvas.removeEventListener('pointerdown', addPolygonVertex);
            canvas.removeEventListener('pointermove', previewPolygon);
            canvas.removeEventListener('pointerup', checkAutoClose);
            canvas.removeEventListener('click', addPoint);
            canvas.removeEventListener('click', showPointCoords);
            canvas.removeEventListener('mousedown', rulerStart);
            canvas.removeEventListener('mousemove', rulerMove);
            canvas.removeEventListener('mouseup', rulerEnd);
            canvas.removeEventListener('touchstart', rulerStart);
            canvas.removeEventListener('touchmove', rulerMove);
            canvas.removeEventListener('touchend', rulerEnd);
            canvas.removeEventListener('pointerdown', rulerStart);
            canvas.removeEventListener('pointermove', rulerMove);
            canvas.removeEventListener('pointerup', rulerEnd);
            buttons.forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
        }

        function saveState() {
            state.history.push(canvas.toDataURL());
            if (state.history.length > 20) state.history.shift();
            state.redoHistory = [];
            state.polygonHistory.push([...state.polygons]);
            if (state.polygonHistory.length > 20) state.polygonHistory.shift();
            state.redoPolygonHistory = [];
        }

        function undo() {
            if (state.history.length > 0) {
                const img = new Image();
                const lastState = state.history.pop();
                state.redoHistory.push(canvas.toDataURL());
                img.src = lastState;
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    if (state.polygonHistory.length > 0) {
                        state.redoPolygonHistory.push([...state.polygons]);
                        state.polygons = [...state.polygonHistory.pop()];
                    } else {
                        state.polygons = [];
                    }
                    redrawAll();
                };
            }
        }

        function redo() {
            if (state.redoHistory.length > 0) {
                const img = new Image();
                const nextState = state.redoHistory.pop();
                state.history.push(canvas.toDataURL());
                img.src = nextState;
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    if (state.redoPolygonHistory.length > 0) {
                        state.polygonHistory.push([...state.polygons]);
                        state.polygons = [...state.redoPolygonHistory.pop()];
                    }
                    redrawAll();
                };
            }
        }

        function clearAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            state.polygons = [];
            state.circles = [];
            state.points = [];
            state.functions = [];
            state.grid = null;
            state.numberLine = null;
            state.ruler = null;
            state.polygonHistory = [];
            state.redoPolygonHistory = [];
            saveState();
        }

        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (state.grid) drawGridLines(state.grid);
            if (state.numberLine) drawNumberLineLines(state.numberLine);
            state.polygons.forEach(drawPolygon);
            state.circles.forEach(drawCircle);
            state.points.forEach(drawPoint);
            state.functions.forEach(drawFunctionGraph);
            if (state.ruler && state.ruler.active) drawRuler();
        }

        function drawPolygon(poly) {
            ctx.beginPath();
            ctx.moveTo(poly.points[0].x, poly.points[0].y);
            poly.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.lineWidth = ctx.lineWidth * 2;
            ctx.strokeStyle = poly.color || document.getElementById('colorPicker').value || 'black';
            ctx.stroke();
            ctx.lineWidth = parseInt(document.getElementById('lineWidth').value);

            poly.points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = poly.color || document.getElementById('colorPicker').value || 'black';
                ctx.fill();
                ctx.strokeStyle = poly.color || document.getElementById('colorPicker').value || 'black';
                ctx.stroke();
            });
        }

        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            } else if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            }
            return { r, g, b };
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }

        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function darkenColor(color, amount) {
            let usePound = false;
            if (color[0] === "#") {
                color = color.slice(1);
                usePound = true;
            }
            const { r, g, b } = hexToRgb("#" + color);
            let [h, s, l] = rgbToHsl(r, g, b);
            l = Math.max(0, l - amount);
            const [newR, newG, newB] = hslToRgb(h, s, l);
            const result = ((newR << 16) | (newG << 8) | newB).toString(16).padStart(6, '0');
            return (usePound ? "#" : "") + result;
        }

        function drawCircle(circle) {
            ctx.beginPath();
            ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            const originalColor = circle.color;
            const darkerColor = darkenColor(originalColor, 30);
            ctx.strokeStyle = darkerColor;
            ctx.stroke();
        }

        function drawPoint(point) {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = point.color;
            ctx.fill();
        }

        function drawFunctionGraph(func) {
            ctx.beginPath();
            ctx.moveTo(func.points[0].x, func.points[0].y);
            func.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.strokeStyle = func.color;
            ctx.stroke();
            ctx.fillStyle = func.color;
            ctx.fillText(func.label, func.labelX, func.labelY);
        }

        function drawRuler() {
            ctx.beginPath();
            ctx.moveTo(state.ruler.startX, state.ruler.startY);
            ctx.lineTo(state.ruler.endX, state.ruler.endY);
            ctx.strokeStyle = 'purple';
            ctx.stroke();

            let distanceInPixels = Math.sqrt((state.ruler.endX - state.ruler.startX) ** 2 + (state.ruler.endY - state.ruler.startY) ** 2);
            let distanceInCm = distanceInPixels / 37.8;

            ctx.fillText(`المسافة: ${distanceInCm.toFixed(2)} سم`, (state.ruler.startX + state.ruler.endX) / 2, (state.ruler.startY + state.ruler.endY) / 2);
        }

        function startPen() {
            canvas.addEventListener('pointerdown', penStart);
        }

        function penStart(e) {
            e.preventDefault();
            state.drawing = true;
            const coords = getEventCoords(e);
            state.startX = coords.x;
            state.startY = coords.y;
            ctx.beginPath();
            ctx.moveTo(state.startX, state.startY);
            canvas.addEventListener('pointermove', penDraw);
            canvas.addEventListener('pointerup', endPosition);
        }

        function penDraw(e) {
            if (!state.drawing || state.tool !== 'penBtn') return;
            e.preventDefault();
            const coords = getEventCoords(e);
            ctx.lineTo(coords.x, coords.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(coords.x, coords.y);
        }

        function endPosition(e) {
            e.preventDefault();
            state.drawing = false;
            canvas.removeEventListener('pointermove', penDraw);
            canvas.removeEventListener('pointerup', endPosition);
            saveState();
        }

        function startEraser() {
            canvas.addEventListener('pointerdown', eraserStart);
        }

        function eraserStart(e) {
            e.preventDefault();
            state.drawing = true;
            const coords = getEventCoords(e);
            ctx.beginPath();
            ctx.moveTo(coords.x, coords.y);
            canvas.addEventListener('pointermove', erase);
            canvas.addEventListener('pointerup', endPosition);
        }

        function erase(e) {
            if (!state.drawing || state.tool !== 'eraserBtn') return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const eraserSize = parseInt(document.getElementById('eraserSize').value);
            ctx.globalCompositeOperation = 'destination-out';
            ctx.lineWidth = eraserSize;
            ctx.lineTo(coords.x, coords.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(coords.x, coords.y);
            ctx.globalCompositeOperation = 'source-over';
            saveState();
        }

        function startCompass() {
            canvas.addEventListener('pointerdown', compassStart);
        }

        function compassStart(e) {
            e.preventDefault();
            state.drawing = true;
            const coords = getEventCoords(e);
            state.startX = coords.x;
            state.startY = coords.y;
            canvas.addEventListener('pointermove', previewRadius);
            canvas.addEventListener('pointerup', finishCircle);
        }

        function previewRadius(e) {
            if (!state.drawing || state.tool !== 'compassBtn') return;
            e.preventDefault();
            redrawAll();
            const coords = getEventCoords(e);
            const radius = Math.sqrt((coords.x - state.startX) ** 2 + (coords.y - state.startY) ** 2);
            const radiusInCm = radius / 37.8;

            ctx.beginPath();
            ctx.moveTo(state.startX, state.startY);
            ctx.lineTo(coords.x, coords.y);
            ctx.strokeStyle = 'gray';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillText(`نصف القطر: ${Math.round(radiusInCm * 10) / 10} سم`, coords.x + 10, coords.y - 10);
        }

        function finishCircle(e) {
            if (!state.drawing || state.tool !== 'compassBtn') return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const radius = Math.sqrt((coords.x - state.startX) ** 2 + (coords.y - state.startY) ** 2);
            state.circles.push({ x: state.startX, y: state.startY, radius: radius, color: ctx.strokeStyle });
            redrawAll();
            saveState();
            state.drawing = false;
            canvas.removeEventListener('pointermove', previewRadius);
            canvas.removeEventListener('pointerup', finishCircle);
        }

        function snapToGrid(coords) {
            if (!state.grid) return coords;
            const { step } = state.grid;
            const pixelsPerCm = 37.8;
            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;

            const xUnit = (coords.x - canvasCenterX) / pixelsPerCm;
            const yUnit = -(coords.y - canvasCenterY) / pixelsPerCm;

            const snappedXUnit = Math.round(xUnit / step) * step;
            const snappedYUnit = Math.round(yUnit / step) * step;

            const snappedX = snappedXUnit * pixelsPerCm + canvasCenterX;
            const snappedY = -snappedYUnit * pixelsPerCm + canvasCenterY;

            return { x: snappedX, y: snappedY };
        }

        function startPolygon() {
            state.currentPolygon = [];
            canvas.addEventListener('pointerdown', addPolygonVertex);
            canvas.addEventListener('pointermove', previewPolygon);
            canvas.addEventListener('pointerup', checkAutoClose);
        }

        function addPolygonVertex(e) {
            if (state.tool !== 'polygonBtn') return;
            e.preventDefault();
            let coords = getEventCoords(e);

            coords = snapToGrid(coords);

            if (state.currentPolygon.length > 0) {
                const lastPoint = state.currentPolygon[state.currentPolygon.length - 1];
                if (Math.abs(coords.x - lastPoint.x) < 5 && Math.abs(coords.y - lastPoint.y) < 5) return;
            }
            state.currentPolygon.push({ x: coords.x, y: coords.y });
            redrawAll();
            state.currentPolygon.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, i === 0 ? 4 : 4, 0, Math.PI * 2);
                ctx.fillStyle = 'red';
                ctx.fill();
            });
        }

        function previewPolygon(e) {
            if (state.tool !== 'polygonBtn' || state.currentPolygon.length === 0) return;
            e.preventDefault();
            redrawAll();
            ctx.beginPath();
            ctx.moveTo(state.currentPolygon[0].x, state.currentPolygon[0].y);
            state.currentPolygon.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
            const coords = getEventCoords(e);
            const firstPoint = state.currentPolygon[0];
            const radius = 4;
            const distance = Math.sqrt((coords.x - firstPoint.x) ** 2 + (coords.y - firstPoint.y) ** 2);

            if (distance <= radius && state.currentPolygon.length >= 3) {
                ctx.lineTo(firstPoint.x, firstPoint.y);
            } else {
                ctx.lineTo(coords.x, coords.y);
            }
            ctx.strokeStyle = 'gray';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(firstPoint.x, firstPoint.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
        }

        function checkAutoClose(e) {
            if (state.tool !== 'polygonBtn' || state.currentPolygon.length < 3) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const firstPoint = { ...state.currentPolygon[0] };
            const radius = 4;
            const distance = Math.sqrt((coords.x - firstPoint.x) ** 2 + (coords.y - firstPoint.y) ** 2);

            if (distance <= radius) {
                state.currentPolygon.push({ x: firstPoint.x, y: firstPoint.y });
                const selectedColor = document.getElementById('colorPicker').value || 'black';
                state.polygons.push({ points: [...state.currentPolygon], color: selectedColor });
                state.currentPolygon = [];
                redrawAll();
                saveState();
                canvas.removeEventListener('pointerdown', addPolygonVertex);
                canvas.removeEventListener('pointermove', previewPolygon);
                canvas.removeEventListener('pointerup', checkAutoClose);
            }
        }

        function startPoint() {
            canvas.addEventListener('click', addPoint);
        }

        function addPoint(e) {
            if (state.tool !== 'pointBtn') return;
            const coords = getEventCoords(e);
            state.points.push({ x: coords.x, y: coords.y, color: ctx.strokeStyle });
            redrawAll();
            saveState();
            canvas.removeEventListener('click', addPoint);
            canvas.addEventListener('click', showPointCoords);
        }

        function showPointCoords(e) {
            if (state.tool !== 'pointBtn') return;
            const coords = getEventCoords(e);
            state.points.forEach(point => {
                const dist = Math.sqrt((coords.x - point.x) ** 2 + (coords.y - point.y) ** 2);
                if (dist < 10) {
                    const xCoord = (point.x - canvas.width / 2) / 37.8;
                    const yCoord = -(point.y - canvas.height / 2) / 37.8;
                    alert(`الإحداثيات: (${xCoord.toFixed(1)}, ${yCoord.toFixed(1)})`);
                }
            });
        }

        function drawGrid() {
            let step = parseInt(document.getElementById('step').value) || 1;
            if (step <= 0) {
                alert("يرجى إدخال قفزة صحيحة أكبر من 0!");
                return;
            }

            const pixelsPerCm = 37.8;
            const canvasWidthCm = canvas.width / pixelsPerCm;
            const canvasHeightCm = canvas.height / pixelsPerCm;

            const maxX = Math.ceil(canvasWidthCm / 2 / step) * step;
            const minX = -maxX;
            const maxY = Math.ceil(canvasHeightCm / 2 / step) * step;
            const minY = -maxY;

            state.grid = { xMax: maxX, xMin: minX, yMax: maxY, yMin: minY, step };
            redrawAll();
            document.getElementById('gridInput').style.display = 'none';
            saveState();
        }

        function drawGridLines(grid) {
            const { xMax, xMin, yMax, yMin, step } = grid;
            const pixelsPerCm = 37.8;
            const stepInPixels = step * pixelsPerCm;

            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 0.5;
            ctx.fillStyle = 'black';
            ctx.font = '12px Cairo';

            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;

            let xValue = xMin;
            for (let x = canvasCenterX + (xMin * pixelsPerCm); x <= canvasCenterX + (xMax * pixelsPerCm); x += stepInPixels) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                if (xValue !== 0) {
                    let displayText = Math.abs(xValue).toString();
                    if (xValue < 0) displayText += '-';
                    ctx.fillText(displayText, x - ctx.measureText(displayText).width / 2, canvasCenterY + 15);
                }
                xValue += step;
            }

            let yValue = yMin;
            for (let y = canvasCenterY - (yMin * pixelsPerCm); y >= canvasCenterY - (yMax * pixelsPerCm); y -= stepInPixels) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
                if (yValue !== 0) {
                    let displayText = Math.abs(yValue).toString();
                    if (yValue < 0) displayText += '-';
                    ctx.fillText(displayText, canvasCenterX - ctx.measureText(displayText).width - 5, y + 5);
                }
                yValue += step;
            }

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvasCenterY);
            ctx.lineTo(canvas.width, canvasCenterY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(canvas.width - 10, canvasCenterY - 5);
            ctx.lineTo(canvas.width, canvasCenterY);
            ctx.lineTo(canvas.width - 10, canvasCenterY + 5);
            ctx.fill();
            ctx.fillText("X", canvas.width - 20, canvasCenterY - 10);

            ctx.beginPath();
            ctx.moveTo(canvasCenterX, 0);
            ctx.lineTo(canvasCenterX, canvas.height);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(canvasCenterX - 5, 10);
            ctx.lineTo(canvasCenterX, 0);
            ctx.lineTo(canvasCenterX + 5, 10);
            ctx.fill();
            ctx.fillText("Y", canvasCenterX + 10, 15);

            ctx.fillText("0", canvasCenterX - ctx.measureText("0").width - 5, canvasCenterY + 15);
        }

        function drawNumberLine() {
            const nl = {
                max: 10,
                min: -10,
                step: parseInt(document.getElementById('nlStep').value) || 1
            };
            if (!nl.step || nl.step <= 0) {
                alert("يرجى إدخال قفزة صحيحة أكبر من 0!");
                return;
            }
            state.numberLine = nl;
            redrawAll();
            document.getElementById('numberLineInput').style.display = 'none';
            saveState();
        }

        function drawNumberLineLines(nl) {
            const { max, min, step } = nl;
            const y = canvas.height / 2;
            const margin = 20;
            const pixelsPerCm = 37.8;
            const totalUnits = (max - min) / step;
            const totalWidth = canvas.width - 2 * margin;
            const unitWidth = totalWidth / totalUnits;

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, y);
            ctx.lineTo(canvas.width - margin, y);
            ctx.stroke();

            ctx.font = '16px Cairo';
            ctx.fillStyle = 'black';

            let value = min;
            let x = margin;
            const textRotationThreshold = 20;

            for (let i = 0; i <= totalUnits; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y - 10);
                ctx.lineTo(x, y + 10);
                ctx.stroke();

                const nextX = x + unitWidth;
                const textWidth = ctx.measureText(value.toString()).width;
                const isOverlapping = (nextX - x) < textWidth + 5;

                ctx.save();
                if (isOverlapping) {
                    ctx.translate(x, y + 25);
                    ctx.rotate(-Math.PI / 2);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                } else {
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                }

                let displayText = Math.abs(value).toString();
                if (value < 0) displayText += '-';

                if (isOverlapping) {
                    ctx.fillText(displayText, 0, 0);
                } else {
                    ctx.fillText(displayText, x, y + 25);
                }

                ctx.restore();

                value += step;
                x += unitWidth;
            }
        }

        function drawFunction() {
            if (!state.grid) {
                alert("ارسم شبكة أولاً!");
                return;
            }
            const input = document.getElementById('funcInput').value;
            const label = document.getElementById('funcLabel').value || input;
            try {
                const expr = input
                    .replace(/sin/g, 'Math.sin')
                    .replace(/cos/g, 'Math.cos')
                    .replace(/tan/g, 'Math.tan')
                    .replace(/sqrt/g, 'Math.sqrt')
                    .replace(/log/g, 'Math.log')
                    .replace(/x/g, '(x)')
                    .replace(/\^/g, '**');
                const func = x => eval(expr);
                const { xMax, xMin, yMax, yMin } = state.grid;
                const xRange = xMax - xMin;
                const yRange = yMax - yMin;
                const points = [];
                const step = (xMax - xMin) / 500;
                for (let x = xMin; x <= xMax; x += step) {
                    const y = func(x);
                    if (isNaN(y) || y === Infinity || y === -Infinity) continue;
                    const px = (x - xMin) / xRange * canvas.width;
                    const py = canvas.height - (y - yMin) / yRange * canvas.height;
                    points.push({ x: px, y: py });
                }
                if (points.length < 2) throw new Error("لا توجد نقاط كافية للرسم");
                state.functions.push({ points, color: ctx.strokeStyle, label, labelX: canvas.width / 2, labelY: 50 });
                redrawAll();
                saveState();
                document.getElementById('functionInput').style.display = 'none';
            } catch (e) {
                alert("خطأ في الدالة أو لا يمكن رسمها على الشبكة الحالية!");
                console.error(e);
            }
        }

        function showTransformMenu() {
            if (state.polygons.length === 0) {
                alert("ارسم مضلعًا أولاً!");
                return;
            }
            if (!state.grid) {
                alert("ارسم شبكة أولاً لاستخدام التحويل بوحدات المربعات!");
                return;
            }
            alert("انقر على المضلع لتحديده.");
            canvas.addEventListener('click', selectPolygon);
            document.getElementById('transformMenu').style.display = 'block';
            makePanelDraggable('transformMenu');
        }

        let selectedPolygon = null;
        function selectPolygon(e) {
            const coords = getEventCoords(e);
            const x = coords.x;
            const y = coords.y;
            state.polygons.forEach((poly, i) => {
                ctx.beginPath();
                ctx.moveTo(poly.points[0].x, poly.points[0].y);
                poly.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                if (ctx.isPointInPath(x, y)) {
                    selectedPolygon = i;
                    alert("تم اختيار المضلع!");
                    canvas.removeEventListener('click', selectPolygon);
                }
            });
        }

        function applyTransform() {
            if (selectedPolygon === null) {
                alert("اختر مضلعًا أولاً!");
                return;
            }
            if (!state.grid) {
                alert("ارسم شبكة أولاً!");
                return;
            }
            const { xMax, xMin, yMax, yMin } = state.grid;
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            const xUnit = canvas.width / xRange;
            const yUnit = canvas.height / yRange;

            const shiftX = (parseFloat(document.getElementById('shiftX').value) || 0) * xUnit;
            const shiftY = (parseFloat(document.getElementById('shiftY').value) || 0) * yUnit;
            const scale = parseFloat(document.getElementById('scale').value) || 1;
            const rotate = -(parseInt(document.getElementById('rotate').value) || 0) * Math.PI / 180;

            const poly = state.polygons[selectedPolygon];
            poly.points = poly.points.map(p => {
                const tx = p.x - canvas.width / 2;
                const ty = p.y - canvas.height / 2;
                const rx = tx * Math.cos(rotate) - ty * Math.sin(rotate);
                const ry = tx * Math.sin(rotate) + ty * Math.cos(rotate);
                return {
                    x: rx * scale + canvas.width / 2 + shiftX,
                    y: ry * scale + canvas.height / 2 + shiftY
                };
            });
            redrawAll();
            saveState();
            document.getElementById('transformMenu').style.display = 'none';
        }

        function closeTransformMenu() {
            document.getElementById('transformMenu').style.display = 'none';
            selectedPolygon = null;
        }

        function makePanelDraggable(panelId) {
            const panel = document.getElementById(panelId);
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            panel.addEventListener('mousedown', startDragging);
            panel.addEventListener('touchstart', startDragging);

            function startDragging(e) {
                initialX = e.type === 'touchstart' ? e.touches[0].clientX - currentX : e.clientX - currentX;
                initialY = e.type === 'touchstart' ? e.touches[0].clientY - currentY : e.clientY - currentY;
                isDragging = true;
                panel.classList.add('dragging');
            }

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag);

            document.addEventListener('mouseup', stopDragging);
            document.addEventListener('touchend', stopDragging);

            function drag(e) {
                if (!isDragging) return;
                e.preventDefault();
                currentX = (e.type === 'touchmove' ? e.touches[0].clientX : e.clientX) - initialX;
                currentY = (e.type === 'touchmove' ? e.touches[0].clientY : e.clientY) - initialY;

                const minX = 0;
                const maxX = window.innerWidth - panel.offsetWidth;
                const minY = 0;
                const maxY = window.innerHeight - panel.offsetHeight;

                currentX = Math.max(minX, Math.min(maxX, currentX));
                currentY = Math.max(minY, Math.min(maxY, currentY));

                panel.style.left = currentX + 'px';
                panel.style.top = currentY + 'px';
                panel.style.right = 'auto';
                panel.style.position = 'fixed';
            }

            function stopDragging() {
                isDragging = false;
                panel.classList.remove('dragging');
            }

            panel.style.left = '20px';
            panel.style.top = '20%';
            panel.style.right = 'auto';
            panel.style.position = 'fixed';
        }

        function showMultiplicationTable() {
            const table = document.getElementById('multiplicationTable');
            table.style.display = 'block';
            const content = document.getElementById('tableContent');
            content.innerHTML = '';
            const questions = [];
            for (let i = 0; i < 10; i++) {
                const a = Math.floor(Math.random() * 12) + 1;
                const b = Math.floor(Math.random() * 12) + 1;
                questions.push({ a, b, answer: a * b });
            }
            questions.forEach(q => {
                const div = document.createElement('div');
                div.style.cursor = 'pointer';
                div.textContent = `${q.a} × ${q.b} = ?`;
                div.onclick = () => div.textContent = `${q.a} × ${q.b} = ${q.answer}`;
                content.appendChild(div);
            });
        }

        function startRuler() {
            canvas.addEventListener('pointerdown', rulerStart);
        }

        function rulerStart(e) {
            e.preventDefault();
            const coords = getEventCoords(e);
            state.ruler = { active: true, startX: coords.x, startY: coords.y, endX: 0, endY: 0 };
            canvas.addEventListener('pointermove', rulerMove);
            canvas.addEventListener('pointerup', rulerEnd);
        }

        function rulerMove(e) {
            e.preventDefault();
            const coords = getEventCoords(e);
            state.ruler.endX = coords.x;
            state.ruler.endY = coords.y;
            redrawAll();
        }

        function rulerEnd(e) {
            e.preventDefault();
            state.ruler.active = false;
            redrawAll();
            saveState();
            canvas.removeEventListener('pointermove', rulerMove);
            canvas.removeEventListener('pointerup', rulerEnd);
        }

        let timerInterval = null;

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            let seconds = parseInt(prompt("أدخل الوقت بالثواني:", "60")) || 60;
            const timerDisplay = document.getElementById('timer');
            timerDisplay.textContent = `00:${seconds.toString().padStart(2, '0')}`;
            isWhistlePlaying = false;

            timerInterval = setInterval(() => {
                seconds--;
                if (seconds < 0) {
                    clearInterval(timerInterval);
                    timerDisplay.textContent = "انتهى!";
                    timerDisplay.classList.add('warning');
                    playLongBeep();
                    return;
                }
                timerDisplay.textContent = `00:${seconds.toString().padStart(2, '0')}`;
                if (seconds <= 10) {
                    timerDisplay.classList.add('warning');
                    if (!isWhistlePlaying) {
                        playBeep(200);
                        isWhistlePlaying = true;
                        setTimeout(() => {
                            isWhistlePlaying = false;
                        }, 300);
                    }
                }
            }, 1000);
            saveState();
        }

        function takeScreenshot() {
            const link = document.createElement('a');
            link.download = `math_board_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            saveState();
        }

        // دالة لخلط القائمة عشوائيًا (Fisher-Yates Shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function spinWheel() {
            let names = document.getElementById('studentNames').value.split('\n').filter(n => n.trim());
            if (names.length === 0) {
                alert("أدخل أسماء الطلاب أولاً!");
                return;
            }

            // خلط الأسماء عشوائيًا عند تهيئة القائمة
            if (state.remainingNames.length === 0) {
                state.remainingNames = shuffleArray([...names]);
            }

            if (state.remainingNames.length === 0) {
                alert("لا توجد أسماء متبقية! أعد إدخال الأسماء.");
                document.getElementById('studentNames').value = '';
                return;
            }

            const spinnerCanvas = document.getElementById('spinnerCanvas');
            const spinCtx = spinnerCanvas.getContext('2d');
            let angle = 0;
            const baseSpeed = 0.2;
            const spinDuration = 5000;
            let startTime = null;
            const randomExtraSpins = Math.floor(Math.random() * 5) + 5;

            function drawWheel(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                spinCtx.clearRect(0, 0, spinnerCanvas.width, spinnerCanvas.height);

                spinCtx.beginPath();
                spinCtx.arc(200, 200, 180, 0, Math.PI * 2);
                spinCtx.fillStyle = '#f0f0f0';
                spinCtx.fill();

                const namesToShow = state.remainingNames;
                const sliceAngle = (Math.PI * 2) / namesToShow.length;
                for (let i = 0; i < namesToShow.length; i++) {
                    spinCtx.beginPath();
                    spinCtx.moveTo(200, 200);
                    spinCtx.arc(200, 200, 180, angle + i * sliceAngle, angle + (i + 1) * sliceAngle);
                    spinCtx.fillStyle = `hsl(${i * 360 / namesToShow.length}, 70%, 50%)`;
                    spinCtx.fill();
                    spinCtx.lineWidth = 2;
                    spinCtx.strokeStyle = '#000';
                    spinCtx.stroke();
                    spinCtx.save();
                    spinCtx.translate(200, 200);
                    spinCtx.rotate(angle + i * sliceAngle + sliceAngle / 2);
                    spinCtx.textAlign = 'center';
                    spinCtx.fillStyle = 'black';
                    spinCtx.font = '16px Cairo';
                    spinCtx.fillText(namesToShow[i], 120, 0);
                    spinCtx.restore();
                }

                const speed = baseSpeed * (1 - elapsed / spinDuration);
                angle += speed;

                if (elapsed < spinDuration) {
                    requestAnimationFrame(drawWheel);
                } else {
                    const finalAngle = (angle + randomExtraSpins * Math.PI * 2) % (Math.PI * 2);
                    const normalizedAngle = (finalAngle + Math.PI * 2) % (Math.PI * 2);
                    const selectedIndex = Math.floor(normalizedAngle / sliceAngle);
                    const correctedIndex = selectedIndex % namesToShow.length; // اختيار عشوائي بناءً على الزاوية
                    const selectedName = namesToShow[correctedIndex];

                    playBeep(200);
                    alert(`الطالب المختار: ${selectedName}`);
                    state.remainingNames = state.remainingNames.filter(name => name !== selectedName);
                    state.lastSelectedName = selectedName;
                    document.getElementById('studentNames').value = state.remainingNames.join('\n');
                }
            }

            requestAnimationFrame(drawWheel);
        }

        function increment(id, value) {
            const input = document.getElementById(id);
            let current = parseFloat(input.value) || 0;
            input.value = (current + value).toString();
        }

        document.getElementById('colorPicker').addEventListener('change', () => {
            ctx.strokeStyle = document.getElementById('colorPicker').value;
            ctx.fillStyle = document.getElementById('colorPicker').value;
        });

        document.getElementById('lineWidth').addEventListener('change', () => {
            ctx.lineWidth = parseInt(document.getElementById('lineWidth').value);
        });

        document.getElementById('eraserSize').addEventListener('change', () => {
            // لا حاجة لتحديث مباشر لأن الممحاة تعتمد على الحدث أثناء الرسم
        });
    </script>
</body>
</html>